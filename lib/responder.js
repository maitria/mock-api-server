// Generated by CoffeeScript 1.10.0
var Responder, ResponseSpecification, compose, each, extend, filter, identity, keyReplacer, map, patternMatcher, ref, size, sortBy, stripExtension, url;

patternMatcher = require('./pattern_matcher');

ref = require('underscore'), compose = ref.compose, each = ref.each, extend = ref.extend, filter = ref.filter, identity = ref.identity, map = ref.map, size = ref.size, sortBy = ref.sortBy;

url = require('url');

keyReplacer = require('./manipulations').keyReplacer;

stripExtension = function(path) {
  return path.replace(/\.json$/, '');
};

ResponseSpecification = (function() {
  function ResponseSpecification(options) {
    this.method = options.method, this.path = options.path, this.query = options.query, this.body = options.body, this.statusCode = options.statusCode, this.changeNumber = options.changeNumber;
    this.path = stripExtension(this.path);
    if (this.changeNumber == null) {
      this.changeNumber = 0;
    }
    if (options.replaceKey != null) {
      this.body = keyReplacer(options);
    }
  }

  ResponseSpecification.prototype.matches = function(request) {
    if (stripExtension(request.path) !== this.path) {
      return false;
    }
    if (request.method !== this.method) {
      return false;
    }
    return this._matchesQuery(request.query);
  };

  ResponseSpecification.prototype["with"] = function(params) {
    return new ResponseSpecification(extend({}, this, params));
  };

  ResponseSpecification.prototype._matchesQuery = function(query) {
    var matches;
    matches = true;
    each(this.query, (function(_this) {
      return function(value, name) {
        if (!patternMatcher(value)(query[name])) {
          return matches = false;
        }
      };
    })(this));
    return matches;
  };

  return ResponseSpecification;

})();

Responder = (function() {
  function Responder(fsHash) {
    this.specs = this._buildResponseMap(fsHash);
    this.serialNumber = 0;
  }

  Responder.prototype.respondTo = function(request) {
    var allowedEntries, body, bodyTransform, statusCode;
    allowedEntries = filter(this.specs, function(entry) {
      return entry.matches(request);
    });
    if (allowedEntries.length === 0) {
      return void 0;
    }
    bodyTransform = identity;
    body = void 0;
    statusCode = void 0;
    each(allowedEntries, function(entry) {
      if (typeof entry.body === 'function') {
        bodyTransform = compose(entry.body, bodyTransform);
      } else if (typeof body === 'undefined') {
        body = bodyTransform(entry.body);
      }
      return statusCode != null ? statusCode : statusCode = entry.statusCode;
    });
    return {
      statusCode: statusCode,
      body: body
    };
  };

  Responder.prototype.withResponseSpecification = function(newSpec) {
    var answer;
    answer = this._freshCopyWith({
      specs: this._specsWith(newSpec),
      serialNumber: this.serialNumber + 1
    });
    return answer;
  };

  Responder.prototype._specsWith = function(newSpec) {
    var specs;
    specs = this.specs.slice(0);
    specs.push(newSpec["with"]({
      changeNumber: this.serialNumber + 1
    }));
    return this._sortSpecs(specs);
  };

  Responder.prototype._freshCopyWith = function(parameters) {
    return extend(new Responder({}), parameters);
  };

  Responder.prototype._extractMethod = function(filename) {
    var method, path;
    method = filename.split('/')[1];
    path = filename.replace(/\/[^\/]*/, '');
    return {
      method: method,
      path: path
    };
  };

  Responder.prototype._buildResponseMap = function(fsHash) {
    var specs;
    specs = map(fsHash, (function(_this) {
      return function(response, filename) {
        return _this._buildStaticResponseEntry(filename, response);
      };
    })(this));
    return this._sortSpecs(specs);
  };

  Responder.prototype._sortSpecs = function(specs) {
    return sortBy(specs, function(spec) {
      return 1e9 - 1000 * (size(spec.query)) - spec.changeNumber;
    });
  };

  Responder.prototype._buildStaticResponseEntry = function(filename, arg) {
    var body, method, path, pathname, query, ref1, ref2, statusCode;
    body = arg.body, statusCode = arg.statusCode;
    ref1 = url.parse(filename, true), pathname = ref1.pathname, query = ref1.query;
    ref2 = this._extractMethod(stripExtension(pathname)), method = ref2.method, path = ref2.path;
    return new ResponseSpecification({
      body: body,
      statusCode: statusCode,
      method: method,
      path: path,
      query: query
    });
  };

  return Responder;

})();

module.exports = {
  Responder: Responder,
  ResponseSpecification: ResponseSpecification
};
