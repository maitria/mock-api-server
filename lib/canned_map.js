// Generated by CoffeeScript 2.0.0-beta7
void function () {
  var cache$, each, entryAllowedForRequest, entryScore, extractQueryFromFilename, filter, last, parseFilename, parseFilenames, sortBy, stripExtension;
  cache$ = require('underscore');
  each = cache$.each;
  filter = cache$.filter;
  last = cache$.last;
  sortBy = cache$.sortBy;
  stripExtension = function (path) {
    return path.replace(/\.json$/, '');
  };
  extractQueryFromFilename = function (filename) {
    var meta, query;
    meta = last(filename.split('/')).split(',');
    meta.splice(-1, 1);
    query = {};
    each(meta, function (part) {
      var cache$1, name, value;
      cache$1 = part.split('=');
      name = cache$1[0];
      value = cache$1[1];
      return query[name] = value;
    });
    return query;
  };
  parseFilename = function (filename) {
    var basename, dirname, path, query;
    dirname = filename.match(/^.*\//)[0];
    basename = filename.match(/[^,/]*$/)[0];
    path = dirname + stripExtension(basename);
    query = extractQueryFromFilename(filename);
    return {
      path: path,
      query: query
    };
  };
  parseFilenames = function (fsHash) {
    var responseMap;
    responseMap = {};
    each(fsHash, function (content, filename) {
      var fsPath;
      fsPath = parseFilename(filename);
      if (null != responseMap[fsPath.path])
        responseMap[fsPath.path];
      else
        responseMap[fsPath.path] = [];
      return responseMap[fsPath.path].push({
        query: fsPath.query,
        content: content
      });
    });
    return responseMap;
  };
  entryAllowedForRequest = function (request, responseMapEntry) {
    var matches;
    matches = true;
    each(responseMapEntry.query, function (value, name) {
      if (!(request.query[name] === value))
        return matches = false;
    });
    return matches;
  };
  entryScore = function (request, responseMapEntry) {
    var score;
    score = 0;
    each(responseMapEntry.query, function (value, name) {
      if (request.query[name] === value)
        return score += 1;
    });
    return score;
  };
  module.exports = function (fsHash) {
    var responseMap;
    responseMap = parseFilenames(fsHash);
    return function (request) {
      var allowedEntries, entries, prioritizedEntries;
      entries = responseMap[stripExtension(request.path)];
      if (entries === void 0)
        return;
      allowedEntries = filter(entries, function (entry) {
        return entryAllowedForRequest(request, entry);
      });
      if (allowedEntries.length === 0)
        return;
      prioritizedEntries = sortBy(allowedEntries, entryScore);
      return last(prioritizedEntries).content;
    };
  };
}.call(this);
