// Generated by CoffeeScript 2.0.0-beta7
void function () {
  var buildResponseMap, buildStaticResponseEntry, cache$, each, entryAllowedForRequest, extractQueryFromFilename, filter, keys, last, matchesPattern, size, sortBy, stripExtension;
  cache$ = require('underscore');
  each = cache$.each;
  filter = cache$.filter;
  keys = cache$.keys;
  last = cache$.last;
  size = cache$.size;
  sortBy = cache$.sortBy;
  stripExtension = function (path) {
    return path.replace(/\.json$/, '');
  };
  extractQueryFromFilename = function (filename) {
    var meta, query;
    meta = last(filename.split('/')).split(',');
    meta.splice(-1, 1);
    query = {};
    each(meta, function (part) {
      var cache$1, name, value;
      cache$1 = part.split('=');
      name = cache$1[0];
      value = cache$1[1];
      return query[name] = value;
    });
    return query;
  };
  buildStaticResponseEntry = function (filename, content) {
    var basename, dirname, path, query;
    dirname = filename.match(/^.*\//)[0];
    basename = filename.match(/[^,/]*$/)[0];
    path = dirname + stripExtension(basename);
    query = extractQueryFromFilename(filename);
    return {
      path: path,
      query: query,
      content: content
    };
  };
  buildResponseMap = function (fsHash) {
    var responseMap;
    responseMap = {};
    each(fsHash, function (content, filename) {
      var entry;
      entry = buildStaticResponseEntry(filename, content);
      if (null != responseMap[entry.path])
        responseMap[entry.path];
      else
        responseMap[entry.path] = [];
      return responseMap[entry.path].push(entry);
    });
    each(responseMap, function (entries, path) {
      return responseMap[path] = sortBy(entries, function (entry) {
        return 1e9 - size(entry.query);
      });
    });
    return responseMap;
  };
  matchesPattern = function (pattern, value) {
    var currentState, currentStates, FAIL, sawWildcard, START, states, SUCCESS;
    if (!pattern)
      return false;
    states = [];
    FAIL = 0;
    START = 1;
    states[FAIL] = { '%': FAIL };
    currentState = START;
    sawWildcard = false;
    each(pattern, function (char) {
      if (null != states[currentState])
        states[currentState];
      else
        states[currentState] = { '%': FAIL };
      if (char === '%') {
        return states[currentState]['%'] = currentState;
      } else {
        states[currentState][char] = currentState + 1;
        currentState += 1;
        return sawWildcard = false;
      }
    });
    if (null != states[currentState])
      states[currentState];
    else
      states[currentState] = { '%': FAIL };
    SUCCESS = currentState;
    currentStates = {};
    currentStates[START] = true;
    each(value, function (char) {
      var nextStates;
      nextStates = {};
      each(keys(currentStates), function (state) {
        nextStates[states[state]['%']] = true;
        if (null != states[state][char])
          return nextStates[states[state][char]] = true;
      });
      return currentStates = nextStates;
    });
    return null != currentStates[SUCCESS];
  };
  entryAllowedForRequest = function (request, responseMapEntry) {
    var matches;
    matches = true;
    each(responseMapEntry.query, function (value, name) {
      if (!matchesPattern(value, request.query[name]))
        return matches = false;
    });
    return matches;
  };
  module.exports = function (fsHash) {
    var responseMap;
    responseMap = buildResponseMap(fsHash);
    return function (request) {
      var allowedEntries, entries;
      entries = responseMap[stripExtension(request.path)];
      if (entries === void 0)
        return;
      allowedEntries = filter(entries, function (entry) {
        return entryAllowedForRequest(request, entry);
      });
      if (allowedEntries.length === 0)
        return;
      return allowedEntries[0].content;
    };
  };
}.call(this);
